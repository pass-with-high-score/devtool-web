import { Injectable, Logger, NotFoundException, OnModuleInit, BadRequestException } from '@nestjs/common';
import { Subject } from 'rxjs';
import { DatabaseService } from '../database/database.service';
import { R2Service } from '../storage/r2.service';
import { ProxyService } from '../proxy/proxy.service';
import { execSync, spawn } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

export interface FormatOption {
    quality: string;
    value: string;
    filesize?: number; // Estimated file size in bytes
    directLink?: DirectLinkInfo; // Direct download link if available
}

export interface DirectLinkInfo {
    url: string;
    filename: string;
    expiresIn: string;
}

export interface SubtitleInfo {
    lang: string;     // Language code (en, vi, etc.)
    name: string;     // Display name (English, Vietnamese, etc.)
    autoGenerated: boolean;
}

export interface ChapterInfo {
    title: string;
    startTime: number;  // seconds
    endTime: number;    // seconds
}

export interface VideoInfo {
    videoId: string;
    title: string;
    thumbnail: string;
    duration: number;
    author: string;
    videoFormats: FormatOption[];
    audioFormats: FormatOption[];
    subtitles: SubtitleInfo[];
    chapters: ChapterInfo[];  // Video chapters
}

export interface PlaylistVideo {
    videoId: string;
    title: string;
    thumbnail: string;
    duration: number;
    index: number;
}

export interface PlaylistInfo {
    playlistId: string;
    title: string;
    author: string;
    videoCount: number;
    videos: PlaylistVideo[];
}

export interface DownloadRequest {
    url: string;
    formatType: 'video' | 'audio';
    quality: string;
    outputFormat?: string; // video: mp4, webm, mkv | audio: mp3, m4a, opus, flac, wav
    startTime?: string; // Optional: clip start time (seconds or mm:ss)
    endTime?: string;   // Optional: clip end time (seconds or mm:ss)
    clipTitle?: string; // Optional: chapter/clip title to use as filename prefix
    embedSubtitles?: boolean; // Optional: embed subtitles into video
    subtitleLang?: string;    // Optional: subtitle language code (en, vi, etc.)
    sponsorBlock?: boolean;   // Optional: remove sponsor segments using SponsorBlock
    estimatedFilesize?: number; // Optional: estimated file size for auto aria2c
}

export interface DownloadResult {
    id: string;
    videoId: string;
    title: string;
    status: 'pending' | 'queued' | 'processing' | 'completed' | 'failed';
    progress?: number;
    downloadUrl?: string;
    fileSize?: number;
    filename?: string;
    error?: string;
    queuePosition?: number;
}

export interface DirectLinkResult {
    videoId: string;
    title: string;
    directUrl: string;
    filename: string;
    filesize?: number;
    quality: string;
    expiresIn: string; // e.g., "6 hours"
}

interface YtDlpVideoInfo {
    id: string;
    title: string;
    thumbnail: string;
    duration: number;
    uploader: string;
    formats: Array<{
        format_id: string;
        ext: string;
        height?: number;
        vcodec?: string;
        acodec?: string;
        abr?: number;
        filesize?: number;
        filesize_approx?: number;
    }>;
    subtitles?: Record<string, Array<{ ext: string; url: string; name?: string }>>;
    automatic_captions?: Record<string, Array<{ ext: string; url: string; name?: string }>>;
    chapters?: Array<{ title: string; start_time: number; end_time: number }>;
}

@Injectable()
export class YouTubeService implements OnModuleInit {
    private readonly logger = new Logger(YouTubeService.name);
    private ytdlpPath = 'yt-dlp';
    private cookiesPath: string | null = null;
    // In-memory progress tracking (faster than DB updates)
    private progressMap = new Map<string, number>();

    // Download limits
    private readonly MAX_FILE_SIZE = 2 * 1024 * 1024 * 1024; // 2GB limit

    // Storage quota management
    private readonly STORAGE_QUOTA = 10 * 1024 * 1024 * 1024; // 10GB
    private readonly CLEANUP_THRESHOLD = 0.9; // Start cleanup at 90% (9GB)

    // SSE progress emitter
    private progressSubjects = new Map<string, Subject<DownloadResult>>();

    constructor(
        private readonly databaseService: DatabaseService,
        private readonly r2Service: R2Service,
        private readonly proxyService: ProxyService,
    ) { }

    async onModuleInit() {
        await this.initTable();
        this.checkYtDlp();
        this.checkCookies();
    }

    private checkYtDlp() {
        // Try common paths for yt-dlp
        const possiblePaths = [
            'yt-dlp',  // In PATH
            `${process.env.HOME}/.local/bin/yt-dlp`,  // pip user install
            '/usr/local/bin/yt-dlp',  // Homebrew/manual install
            '/usr/bin/yt-dlp',  // apt install
        ];

        for (const ytPath of possiblePaths) {
            try {
                const version = execSync(`${ytPath} --version`, { encoding: 'utf-8' }).trim();
                this.ytdlpPath = ytPath;
                this.logger.log(`üì∫ yt-dlp found at ${ytPath}, version: ${version}`);
                return;
            } catch {
                // Try next path
            }
        }
        this.logger.warn('‚ö†Ô∏è yt-dlp not found. YouTube downloads will not work.');
    }

    private checkCookies() {
        // Check for cookies file from env or default path
        const cookiesFile = process.env.YOUTUBE_COOKIES_PATH || './youtube-cookies.txt';
        if (fs.existsSync(cookiesFile)) {
            this.cookiesPath = cookiesFile;
            this.logger.log(`üç™ YouTube cookies loaded from: ${cookiesFile}`);
        } else {
            this.logger.log('‚ÑπÔ∏è No YouTube cookies file found. Some videos may be blocked.');
        }
    }

    private async initTable() {
        await this.databaseService.sql`
            CREATE TABLE IF NOT EXISTS youtube_downloads (
                id VARCHAR(16) PRIMARY KEY,
                video_id VARCHAR(32) NOT NULL,
                title TEXT,
                thumbnail_url TEXT,
                format_type VARCHAR(10),
                quality VARCHAR(20),
                object_key TEXT,
                filename TEXT,
                file_size BIGINT,
                progress INTEGER DEFAULT 0,
                status VARCHAR(20) DEFAULT 'pending',
                error TEXT,
                created_at TIMESTAMP DEFAULT NOW(),
                expires_at TIMESTAMP
            )
        `;
        this.logger.log('üì∫ YouTube downloads table initialized');
    }

    private generateId(): string {
        return Math.random().toString(36).substring(2, 8) + Date.now().toString(36);
    }

    private extractVideoId(url: string): string | null {
        const patterns = [
            /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
            /youtube\.com\/shorts\/([a-zA-Z0-9_-]{11})/,
        ];
        for (const pattern of patterns) {
            const match = url.match(pattern);
            if (match) return match[1];
        }
        return null;
    }

    /**
     * Get video information using yt-dlp
     */
    async getVideoInfo(url: string): Promise<VideoInfo> {
        const videoId = this.extractVideoId(url);
        if (!videoId) {
            throw new BadRequestException('Invalid YouTube URL');
        }

        // Try without proxy first, then with proxy on failure
        let lastError: Error | null = null;
        const attempts = [false, true]; // [without proxy, with proxy]

        for (const useProxy of attempts) {
            try {
                // Build yt-dlp arguments for getting video info
                const args: string[] = [
                    '-j',                   // Output JSON
                    '--no-download',        // Don't download, just get info
                    '--no-warnings',        // Suppress warnings
                    '--no-check-certificates',
                ];

                // Add cookies if available
                if (this.cookiesPath) {
                    args.push('--cookies', this.cookiesPath);
                }

                // Anti-bot measures with bun runtime
                args.push(
                    '--user-agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    '--no-js-runtimes',     // Disable default deno first
                    '--js-runtimes', 'bun', // Enable bun runtime
                );

                // Add proxy only on retry (second attempt)
                if (useProxy) {
                    const proxy = await this.proxyService.getRandomProxy();
                    if (proxy) {
                        args.push('--proxy', proxy);
                        this.logger.log(`üîÑ Retrying with proxy: ${proxy}`);
                    } else {
                        // No proxy available, skip retry
                        throw lastError || new Error('No proxy available');
                    }
                }

                args.push(url);

                // Build command string
                const command = `${this.ytdlpPath} ${args.map(a => a.includes(' ') ? `"${a}"` : a).join(' ')}`;

                this.logger.log(`üîç Getting video info for: ${videoId}${useProxy ? ' (with proxy)' : ''}`);
                this.logger.debug(`üìã Command: ${command}`);

                const result = execSync(command, {
                    encoding: 'utf-8',
                    maxBuffer: 10 * 1024 * 1024,
                });

                this.logger.log(`‚úÖ Video info retrieved successfully for: ${videoId}`);

                const info: YtDlpVideoInfo = JSON.parse(result);

                // Parse available video formats from yt-dlp response
                const heightToFilesize = new Map<number, number>();
                const bitrateToFilesize = new Map<number, number>();

                for (const format of info.formats || []) {
                    // Video formats: has height and video codec
                    if (format.height && format.vcodec && format.vcodec !== 'none') {
                        const existingSize = heightToFilesize.get(format.height) || 0;
                        const formatSize = format.filesize || format.filesize_approx || 0;
                        if (formatSize > existingSize) {
                            heightToFilesize.set(format.height, formatSize);
                        }
                    }
                    // Audio formats: has audio codec and bitrate
                    if (format.acodec && format.acodec !== 'none' && format.abr) {
                        const bitrate = Math.round(format.abr);
                        const existingSize = bitrateToFilesize.get(bitrate) || 0;
                        const formatSize = format.filesize || format.filesize_approx || 0;
                        if (formatSize > existingSize) {
                            bitrateToFilesize.set(bitrate, formatSize);
                        }
                    }
                }

                // Get best audio size to add to video sizes
                const bestAudioSize = Math.max(...bitrateToFilesize.values(), 0);

                // Build video format options from available heights
                const standardHeights = [2160, 1440, 1080, 720, 480, 360, 240, 144];
                const videoFormats: FormatOption[] = standardHeights
                    .filter(h => heightToFilesize.has(h) || [...heightToFilesize.keys()].some(ah => ah >= h))
                    .slice(0, 5) // Max 5 options
                    .map(h => {
                        // Get filesize for this height, or find closest higher resolution
                        let filesize = heightToFilesize.get(h) || 0;
                        if (!filesize) {
                            const higherRes = [...heightToFilesize.entries()].find(([hh]) => hh >= h);
                            filesize = higherRes ? higherRes[1] : 0;
                        }
                        // Add audio size for video+audio combined estimate
                        const totalSize = filesize + bestAudioSize;
                        return {
                            quality: h >= 2160 ? '4K' : h >= 1440 ? '2K' : `${h}p`,
                            value: String(h),
                            filesize: totalSize > 0 ? totalSize : undefined,
                        };
                    });

                // Fallback if no video formats found
                if (videoFormats.length === 0) {
                    videoFormats.push({ quality: 'Best', value: 'bestvideo' });
                }

                // Build audio format options
                const audioFormats: FormatOption[] = [
                    { quality: 'Best', value: 'bestaudio', filesize: bestAudioSize > 0 ? bestAudioSize : undefined },
                ];

                // Add specific bitrate options if available
                const sortedBitrates = [...bitrateToFilesize.keys()].sort((a, b) => b - a);
                for (const bitrate of sortedBitrates.slice(0, 3)) {
                    if (bitrate >= 64) {
                        audioFormats.push({
                            quality: `${bitrate}kbps`,
                            value: String(bitrate),
                            filesize: bitrateToFilesize.get(bitrate),
                        });
                    }
                }

                this.logger.log(`üìä [${videoId}] Available: ${videoFormats.length} video, ${audioFormats.length} audio formats`);

                // Parse available subtitles
                const subtitles: SubtitleInfo[] = [];
                const langNames: Record<string, string> = {
                    en: 'English', vi: 'Vietnamese', ko: 'Korean', ja: 'Japanese',
                    zh: 'Chinese', es: 'Spanish', fr: 'French', de: 'German',
                    id: 'Indonesian', th: 'Thai', pt: 'Portuguese', ru: 'Russian',
                };

                // Manual subtitles first
                if (info.subtitles) {
                    for (const lang of Object.keys(info.subtitles)) {
                        subtitles.push({
                            lang,
                            name: langNames[lang] || lang.toUpperCase(),
                            autoGenerated: false,
                        });
                    }
                }
                // Then auto-generated
                if (info.automatic_captions) {
                    for (const lang of Object.keys(info.automatic_captions)) {
                        if (!subtitles.find(s => s.lang === lang)) {
                            subtitles.push({
                                lang,
                                name: `${langNames[lang] || lang.toUpperCase()} (Auto)`,
                                autoGenerated: true,
                            });
                        }
                    }
                }

                this.logger.log(`üìù [${videoId}] Available subtitles: ${subtitles.length}`);

                // Parse chapters
                const chapters: ChapterInfo[] = (info.chapters || []).map(ch => ({
                    title: ch.title,
                    startTime: ch.start_time,
                    endTime: ch.end_time,
                }));
                if (chapters.length > 0) {
                    this.logger.log(`üìñ [${videoId}] Available chapters: ${chapters.length}`);
                }

                return {
                    videoId: info.id,
                    title: info.title || 'Unknown',
                    thumbnail: info.thumbnail || `https://i.ytimg.com/vi/${videoId}/maxresdefault.jpg`,
                    duration: info.duration || 0,
                    author: info.uploader || 'Unknown',
                    videoFormats,
                    audioFormats,
                    subtitles,
                    chapters,
                };
            } catch (error) {
                lastError = error as Error;
                if (!useProxy) {
                    this.logger.warn(`‚ö†Ô∏è Failed without proxy, will retry with proxy: ${(error as Error).message?.substring(0, 100)}`);
                    continue; // Try again with proxy
                }
                // Both attempts failed
                this.logger.error('Failed to get video info:', error);
            }
        }

        // All attempts failed, fallback to oEmbed
        return this.getVideoInfoFallback(url, videoId);
    }

    private async getVideoInfoFallback(url: string, videoId: string): Promise<VideoInfo> {
        try {
            const oembedUrl = `https://www.youtube.com/oembed?url=${encodeURIComponent(url)}&format=json`;
            const response = await fetch(oembedUrl);
            if (!response.ok) throw new Error('oEmbed failed');
            const data = await response.json();

            return {
                videoId,
                title: data.title || 'Unknown',
                thumbnail: `https://i.ytimg.com/vi/${videoId}/maxresdefault.jpg`,
                duration: 0,
                author: data.author_name || 'Unknown',
                videoFormats: [
                    { quality: '1080p', value: '1080' },
                    { quality: '720p', value: '720' },
                    { quality: '480p', value: '480' },
                ],
                audioFormats: [
                    { quality: 'Best', value: 'bestaudio' },
                ],
                subtitles: [],
                chapters: [], // Not available in fallback
            };
        } catch {
            throw new BadRequestException('Failed to get video info');
        }
    }

    /**
     * Check if URL is a playlist (exclude Radio/Mix, Liked, Watch Later)
     */
    isPlaylistUrl(url: string): boolean {
        // Exclude special auto-generated lists:
        // RD = Radio/Mix, LL = Liked videos, WL = Watch Later
        if (/list=(RD|LL|WL)/.test(url)) {
            return false;
        }
        return url.includes('list=') || url.includes('/playlist');
    }

    /**
     * Get playlist info using yt-dlp flat-playlist mode
     */
    async getPlaylistInfo(url: string): Promise<PlaylistInfo> {
        try {
            const args = [
                '--flat-playlist',
                '-J',
                '--no-warnings',
                '--extractor-args', 'youtube:player_client=android,web',
            ];

            if (this.cookiesPath) {
                args.push('--cookies', this.cookiesPath);
            }

            args.push(url);

            const result = execSync(`${this.ytdlpPath} ${args.map(a => `"${a}"`).join(' ')}`, {
                encoding: 'utf-8',
                timeout: 60000,
                maxBuffer: 50 * 1024 * 1024, // 50MB buffer for large playlists
            });

            const info = JSON.parse(result);

            // Filter out unavailable videos (no id or title indicates unavailable)
            const availableEntries = (info.entries || []).filter((entry: { id?: string; title?: string }) =>
                entry.id && entry.title && !entry.title.includes('[Private video]') && !entry.title.includes('[Deleted video]')
            );

            const videos: PlaylistVideo[] = availableEntries.map((entry: { id: string; title: string; duration: number }, idx: number) => ({
                videoId: entry.id,
                title: entry.title || `Video ${idx + 1}`,
                thumbnail: `https://i.ytimg.com/vi/${entry.id}/mqdefault.jpg`,
                duration: entry.duration || 0,
                index: idx + 1,
            }));

            const skipped = (info.entries || []).length - videos.length;
            if (skipped > 0) {
                this.logger.log(`‚ö†Ô∏è Skipped ${skipped} unavailable videos from playlist`);
            }
            this.logger.log(`üìã Playlist loaded: ${info.title} (${videos.length} available videos)`);

            return {
                playlistId: info.id || 'unknown',
                title: info.title || 'Playlist',
                author: info.uploader || info.channel || 'Unknown',
                videoCount: videos.length,
                videos,
            };
        } catch (error) {
            this.logger.error('Failed to get playlist info:', error);
            throw new BadRequestException('Failed to get playlist info');
        }
    }

    /**
     * Start download using yt-dlp with queue management
     */
    async startDownload(request: DownloadRequest): Promise<DownloadResult> {
        const id = this.generateId();
        const expiresAt = new Date(Date.now() + 60 * 60 * 1000); // 1 hour
        const videoId = this.extractVideoId(request.url) || 'unknown';
        const isClipMode = !!(request.startTime || request.endTime);

        // Check for existing download (deduplication) - only for full video, not clips
        if (!isClipMode) {
            const existingDownload = await this.findExistingDownload(
                videoId,
                request.formatType,
                request.quality,
                request.outputFormat || (request.formatType === 'video' ? 'mp4' : 'mp3')
            );
            if (existingDownload) {
                // Reset expiry to 1 hour from now and return existing download
                const existingId = existingDownload.id as string;
                await this.databaseService.sql`
                    UPDATE youtube_downloads 
                    SET expires_at = ${expiresAt}
                    WHERE id = ${existingId}
                `;
                this.logger.log(`‚ôªÔ∏è Reusing existing download: ${existingDownload.title} (reset expiry)`);
                return {
                    id: existingId,
                    videoId: existingDownload.video_id as string,
                    title: existingDownload.title as string,
                    status: 'completed' as const,
                    progress: 100,
                    downloadUrl: `/youtube/${existingId}/file`,
                    fileSize: existingDownload.file_size ? parseInt(existingDownload.file_size as string) : undefined,
                    filename: existingDownload.filename as string | undefined,
                };
            }
        }

        try {
            // Get video info first (includes actual filesizes from yt-dlp)
            let title = 'YouTube Video';
            let duration = 0;
            let actualFilesize = 0;
            try {
                const info = await this.getVideoInfo(request.url);
                title = info.title;
                duration = info.duration;

                // Get actual filesize for requested quality from yt-dlp response
                if (request.formatType === 'video') {
                    const format = info.videoFormats.find(f => f.quality === request.quality || f.value === request.quality.replace('p', ''));
                    if (format?.filesize) {
                        actualFilesize = format.filesize;
                    }
                } else {
                    const format = info.audioFormats.find(f => f.quality === request.quality || f.value === request.quality);
                    if (format?.filesize) {
                        actualFilesize = format.filesize;
                    }
                }
            } catch {
                // Ignore error, use default title
            }

            // Check file size - prefer actual filesize from yt-dlp, fallback to estimate
            const isClipMode = !!(request.startTime || request.endTime);
            let estimatedSize = actualFilesize;

            // Fallback to estimated size if no actual filesize available
            if (!estimatedSize && duration > 0) {
                let estimatedBitrate = 1000; // 1 Mbps default
                if (request.formatType === 'video') {
                    const height = parseInt(request.quality.replace('p', '')) || 720;
                    if (height >= 2160) estimatedBitrate = 20000; // 4K ~20Mbps
                    else if (height >= 1440) estimatedBitrate = 12000; // 2K ~12Mbps
                    else if (height >= 1080) estimatedBitrate = 8000; // 1080p ~8Mbps
                    else if (height >= 720) estimatedBitrate = 5000; // 720p ~5Mbps
                    else if (height >= 480) estimatedBitrate = 2500;
                    else estimatedBitrate = 1000;
                } else {
                    estimatedBitrate = 192; // Audio only
                }
                estimatedSize = (duration * estimatedBitrate * 1000) / 8; // bytes
            }

            if (estimatedSize > this.MAX_FILE_SIZE) {
                const sizeMB = Math.round(estimatedSize / 1024 / 1024);
                const maxMB = Math.round(this.MAX_FILE_SIZE / 1024 / 1024);
                this.logger.warn(`‚ö†Ô∏è Video too large: ~${sizeMB}MB (max ${maxMB}MB) - ${title}`);
                if (isClipMode) {
                    throw new BadRequestException(
                        `Full video is too large (~${sizeMB}MB). Clip mode still downloads the entire video first. Maximum allowed is ${maxMB}MB. Try a shorter source video.`
                    );
                } else {
                    throw new BadRequestException(
                        `Video is too large (~${sizeMB}MB). Maximum allowed size is ${maxMB}MB. Try a lower quality or shorter video.`
                    );
                }
            }

            this.logger.log(`üì• [${id}] Starting download: ${title}`);

            // Create database record
            await this.databaseService.sql`
                INSERT INTO youtube_downloads (id, video_id, title, format_type, quality, status, expires_at)
                VALUES (${id}, ${videoId}, ${title}, ${request.formatType}, ${request.quality}, 'processing', ${expiresAt})
            `;

            // Start async download
            this.processDownloadWithYtDlp(id, request);

            return {
                id,
                videoId,
                title,
                status: 'processing',
            };
        } catch (error) {
            this.logger.error(`Failed to start download: ${id}`, error);
            throw error;
        }
    }



    /**
     * Process download using yt-dlp
     */
    private async processDownloadWithYtDlp(id: string, request: DownloadRequest) {
        const tmpDir = os.tmpdir();
        const outputTemplate = path.join(tmpDir, `yt_${id}.%(ext)s`);

        try {
            let formatArg: string;
            let ext: string;
            const outputFormat = request.outputFormat || (request.formatType === 'video' ? 'mp4' : 'mp3');

            if (request.formatType === 'audio') {
                // Audio only - extract to specified format
                formatArg = 'bestaudio';
                ext = outputFormat;
            } else {
                // Video with audio
                const height = request.quality.replace('p', '');

                // Choose format arg based on output format
                if (outputFormat === 'webm') {
                    // For WebM, prefer VP9 codec
                    formatArg = `bestvideo[height<=${height}][vcodec^=vp9]+bestaudio[acodec^=opus]/bestvideo[height<=${height}]+bestaudio/best[height<=${height}]`;
                } else {
                    // For MP4/MKV, prefer H.264 (avc1) for max compatibility
                    formatArg = `bestvideo[height<=${height}][vcodec^=avc1]+bestaudio/bestvideo[height<=${height}]+bestaudio/best[height<=${height}]`;
                }
                ext = outputFormat;
            }

            // Build yt-dlp command with bun runtime
            const args = [
                '-f', formatArg,
                '-o', outputTemplate,
                '--no-playlist',
                '--no-warnings',
                '--user-agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                '--no-js-runtimes',
                '--js-runtimes', 'bun',
                '--no-check-certificates',
                '--retries', '3',
                '--embed-metadata', // Embed video metadata (title, artist, description, etc.)
            ];

            // Add cookies if available
            if (this.cookiesPath) {
                args.push('--cookies', this.cookiesPath);
            }

            // Add proxy if available
            const proxy = await this.proxyService.getRandomProxy();
            if (proxy) {
                args.push('--proxy', proxy);
                this.logger.log(`üåê [${id}] Using proxy: ${proxy}`);
            }

            // Add format-specific options
            if (request.formatType === 'audio') {
                args.push('-x');
                // Audio format options
                switch (outputFormat) {
                    case 'm4a':
                        args.push('--audio-format', 'aac');
                        args.push('--embed-thumbnail'); // m4a supports thumbnail
                        break;
                    case 'opus':
                        args.push('--audio-format', 'opus');
                        args.push('--embed-thumbnail'); // opus supports thumbnail
                        break;
                    case 'flac':
                        args.push('--audio-format', 'flac');
                        args.push('--embed-thumbnail'); // flac supports thumbnail
                        break;
                    case 'wav':
                        args.push('--audio-format', 'wav');
                        // WAV doesn't support thumbnail embedding
                        break;
                    case 'mp3':
                    default:
                        args.push('--audio-format', 'mp3');
                        args.push('--embed-thumbnail'); // mp3 supports thumbnail
                        break;
                }
            } else {
                // Video format options
                args.push('--merge-output-format', outputFormat);
            }

            // Track if we're in clip mode (for disabling aria2c later)
            const isClipMode = !!(request.startTime || request.endTime);

            // Add clip download using --download-sections
            // Note: For long videos this will be slow as it streams from start
            if (isClipMode) {
                const start = request.startTime || '0';
                const end = request.endTime || 'inf';
                args.push('--download-sections', `*${start}-${end}`);
                // CRITICAL: Force keyframes at cut points to ensure accurate clipping
                // Without this, video duration may be wrong and have black frames at the end
                args.push('--force-keyframes-at-cuts');
                // Prevent parallel stream issues that cause black frames
                args.push('--compat-option', 'no-direct-merge');
                this.logger.log(`‚úÇÔ∏è [${id}] Clip mode: ${start} to ${end} (with keyframe re-encoding)`);
            }

            // Add subtitle embedding (video only)
            if (request.embedSubtitles && request.formatType === 'video') {
                const subLang = request.subtitleLang || 'en';
                args.push(
                    '--write-subs',
                    '--write-auto-subs',
                    '--sub-langs', subLang,
                    '--embed-subs',
                    '--convert-subs', 'srt',
                );
                this.logger.log(`üìù [${id}] Embedding subtitles: ${subLang}`);
            }

            // Add SponsorBlock sponsor removal
            if (request.sponsorBlock) {
                args.push('--sponsorblock-remove', 'all');
                this.logger.log(`üö´ [${id}] SponsorBlock: removing sponsor segments`);
            }

            // Auto-use aria2c for large files (>100MB) for faster downloads
            // BUT NOT for clip mode - aria2c conflicts with --download-sections causing black frames
            const ARIA2C_THRESHOLD = 100 * 1024 * 1024; // 100MB
            if (request.estimatedFilesize && request.estimatedFilesize > ARIA2C_THRESHOLD && !isClipMode) {
                args.push(
                    '--downloader', 'aria2c',
                    // -x 16: 16 connections per server
                    // -s 16: 16 connections total
                    // -k 1M: min split size
                    // --summary-interval=1: output progress every 1 second
                    '--downloader-args', 'aria2c:-x 16 -s 16 -k 1M --summary-interval=1'
                );
                this.logger.log(`‚ö° [${id}] Auto-enabling aria2c for large file (~${Math.round(request.estimatedFilesize / 1024 / 1024)}MB)`)
            }

            args.push(request.url);

            // Log the full command for debugging
            const commandString = `${this.ytdlpPath} ${args.map(a => a.includes(' ') ? `"${a}"` : a).join(' ')}`;
            this.logger.log(`üé¨ [${id}] Starting download: ${request.formatType} @ ${request.quality}`);
            this.logger.log(`üìã [${id}] Output: ${outputTemplate}`);
            this.logger.debug(`üìã [${id}] Command: ${commandString}`);

            // Execute yt-dlp
            await new Promise<void>((resolve, reject) => {
                const proc = spawn(this.ytdlpPath, args);
                let stderr = '';
                let lastLoggedProgress = -1;
                let downloadedFileCount = 0; // Track how many files downloaded
                let currentFileProgress = 0; // Progress of current file

                this.logger.log(`üöÄ [${id}] yt-dlp process started (PID: ${proc.pid})`);

                proc.stderr.on('data', (data) => {
                    const text = data.toString();
                    stderr += text;

                    // Detect new file download starting
                    if (text.includes('[download] Destination:')) {
                        downloadedFileCount++;
                        currentFileProgress = 0;
                        this.logger.log(`üì¶ [${id}] Downloading file ${downloadedFileCount}...`);
                    }

                    // Log important yt-dlp messages
                    if (text.includes('[download]') || text.includes('[Merger]') || text.includes('[ExtractAudio]')) {
                        this.logger.debug(`üì• [${id}] ${text.trim()}`);

                        // Detect merge/processing phase
                        if (text.includes('[Merger]')) {
                            this.progressMap.set(id, 100);
                            this.emitProgress(id);
                        }
                    }

                    // Parse progress - handle both yt-dlp and aria2c formats
                    // aria2c format: [#hash 12MiB/132MiB(9%) CN:16 DL:5.2MiB]
                    // yt-dlp format: [download] 45.2% of 100MiB
                    let progress = 0;

                    // Try aria2c format - get ALL matches and take highest (multi-line chunks)
                    const aria2cMatches = text.matchAll(/\((\d+)%\)/g);
                    for (const match of aria2cMatches) {
                        const p = parseInt(match[1]);
                        if (p > progress) progress = p;
                    }

                    // Fallback to yt-dlp format if no aria2c matches
                    if (progress === 0) {
                        const progressMatch = text.match(/(\d+\.?\d*)%/);
                        if (progressMatch) {
                            progress = Math.floor(parseFloat(progressMatch[1]));
                        }
                    }

                    if (progress > 0) {
                        progress = Math.min(progress, 100);
                        currentFileProgress = progress;

                        // For multi-file downloads: show combined progress
                        // File 1 = 0-50%, File 2 = 50-100%
                        let displayProgress = progress;
                        if (downloadedFileCount === 1) {
                            displayProgress = Math.floor(progress / 2); // First file: 0-50%
                        } else if (downloadedFileCount === 2) {
                            displayProgress = 50 + Math.floor(progress / 2); // Second file: 50-100%
                        }

                        this.progressMap.set(id, displayProgress);
                        // Emit SSE event
                        this.emitProgress(id);

                        // Log every 25% progress
                        if (displayProgress >= lastLoggedProgress + 25) {
                            this.logger.log(`üìä [${id}] Progress: ${displayProgress}%`);
                            lastLoggedProgress = displayProgress;
                        }
                    }
                });

                proc.stdout.on('data', (data) => {
                    const text = data.toString();
                    this.logger.debug(`yt-dlp: ${text.trim()}`);

                    // Detect new file download from stdout (aria2c)
                    if (text.includes('[download] Destination:') || text.includes('FILE:')) {
                        if (!text.includes('.part')) { // Ignore .part file lines
                            downloadedFileCount++;
                            currentFileProgress = 0;
                        }
                    }

                    // Parse progress from stdout (aria2c outputs here)
                    // Get ALL matches and take highest for multi-line chunks
                    let progress = 0;
                    const aria2cMatches = text.matchAll(/\((\d+)%\)/g);
                    for (const match of aria2cMatches) {
                        const p = parseInt(match[1]);
                        if (p > progress) progress = p;
                    }

                    // Fallback to yt-dlp format
                    if (progress === 0) {
                        const progressMatch = text.match(/(\d+\.?\d*)%/);
                        if (progressMatch) {
                            progress = Math.floor(parseFloat(progressMatch[1]));
                        }
                    }

                    if (progress > 0) {
                        progress = Math.min(progress, 100);
                        currentFileProgress = progress;

                        // For multi-file downloads: show combined progress
                        let displayProgress = progress;
                        if (downloadedFileCount === 1) {
                            displayProgress = Math.floor(progress / 2);
                        } else if (downloadedFileCount >= 2) {
                            displayProgress = 50 + Math.floor(progress / 2);
                        }

                        this.progressMap.set(id, displayProgress);
                        this.emitProgress(id);
                    }
                });

                proc.on('close', (code) => {
                    if (code === 0) {
                        this.logger.log(`‚úÖ [${id}] yt-dlp process completed successfully`);
                        resolve();
                    } else {
                        this.logger.error(`‚ùå [${id}] yt-dlp exited with code ${code}`);
                        this.logger.error(`‚ùå [${id}] stderr: ${stderr.slice(-500)}`);
                        reject(new Error(stderr || `yt-dlp exited with code ${code}`));
                    }
                });

                proc.on('error', (err) => {
                    this.logger.error(`‚ùå [${id}] yt-dlp process error: ${err.message}`);
                    reject(err);
                });
            });

            // Find the downloaded file
            this.logger.log(`üîç [${id}] Looking for downloaded file...`);
            const expectedPath = path.join(tmpDir, `yt_${id}.${ext}`);
            let downloadedFile = expectedPath;

            // Check if file exists, if not try to find it
            if (!fs.existsSync(downloadedFile)) {
                const files = fs.readdirSync(tmpDir).filter(f => f.startsWith(`yt_${id}`));
                if (files.length > 0) {
                    downloadedFile = path.join(tmpDir, files[0]);
                    ext = path.extname(files[0]).slice(1);
                    this.logger.log(`üìÅ [${id}] Found file: ${files[0]}`);
                } else {
                    throw new Error('Downloaded file not found');
                }
            } else {
                this.logger.log(`üìÅ [${id}] Found file at expected path`);
            }

            // For clip mode: remux to fix container metadata duration
            // The clipped file may contain extra streams (like subtitle/data) with original video duration
            // QuickTime reads duration from the longest stream, causing wrong display
            // We remux with explicit stream mapping to strip extra streams and fix metadata
            if (isClipMode && request.formatType === 'video') {
                const fixedFile = path.join(tmpDir, `yt_${id}_fixed.${ext}`);
                this.logger.log(`üîß [${id}] Fixing clip metadata with ffmpeg remux...`);
                try {
                    execSync(
                        // Map only video (0:v:0) and audio (0:a:0) streams, strip everything else
                        // -map_chapters -1: Remove chapters that have timestamps from original video (causes wrong duration)
                        // -movflags +faststart moves metadata to front for better streaming
                        `ffmpeg -y -i "${downloadedFile}" -map 0:v:0 -map 0:a:0 -map_chapters -1 -c copy -movflags +faststart "${fixedFile}"`,
                        { encoding: 'utf-8', timeout: 60000 }
                    );
                    // Replace original with fixed file
                    fs.unlinkSync(downloadedFile);
                    fs.renameSync(fixedFile, downloadedFile);
                    this.logger.log(`‚úÖ [${id}] Clip metadata fixed successfully`);
                } catch (remuxError) {
                    this.logger.warn(`‚ö†Ô∏è [${id}] Failed to fix clip metadata: ${remuxError}`);
                    // Continue with original file if remux fails
                }
            }

            // Upload to R2 using streaming (memory efficient)
            const videoTitle = (await this.getVideoTitle(id)) || 'video';
            // Build filename: use clipTitle as prefix if provided (for chapter downloads)
            const sanitize = (s: string) => s.replace(/[<>:"/\\|?*\x00-\x1f]/g, '').trim();
            let displayFilename: string;
            if (request.clipTitle && isClipMode) {
                // Format: ClipTitle_VideoTitle.ext
                const clipPart = sanitize(request.clipTitle).substring(0, 50);
                const videoPart = sanitize(videoTitle).substring(0, 100);
                displayFilename = `${clipPart}_${videoPart}.${ext}`;
            } else {
                displayFilename = `${sanitize(videoTitle).substring(0, 150)}.${ext}`;
            }
            const objectKey = `youtube/${id}/video.${ext}`; // Simple R2-safe key

            // Get content type based on extension
            const contentTypeMap: Record<string, string> = {
                // Video
                mp4: 'video/mp4',
                webm: 'video/webm',
                mkv: 'video/x-matroska',
                // Audio
                mp3: 'audio/mpeg',
                m4a: 'audio/mp4',
                opus: 'audio/opus',
                flac: 'audio/flac',
                wav: 'audio/wav',
            };
            const contentType = contentTypeMap[ext] || (request.formatType === 'video' ? 'video/mp4' : 'audio/mpeg');

            // Check storage quota and cleanup if needed before upload
            const tempFileStats = fs.statSync(downloadedFile);
            const tempFileSize = tempFileStats.size;
            await this.cleanupStorageIfNeeded(tempFileSize);

            this.logger.log(`‚òÅÔ∏è [${id}] Uploading to R2 (streaming)...`);
            // Set progress > 100 to indicate uploading phase (101-200 = uploading 0-99%)
            this.progressMap.set(id, 101);
            await this.databaseService.sql`
                UPDATE youtube_downloads SET status = 'uploading' WHERE id = ${id}
            `;
            // Emit SSE event for upload phase
            this.emitProgress(id);

            // Upload with progress callback
            let lastUploadPercent = -1;
            const fileSize = await this.r2Service.uploadObjectFromFile(
                objectKey,
                downloadedFile,
                contentType,
                (percent) => {
                    // Map upload percent to 101-200 range (101 = 0%, 200 = 99%)
                    this.progressMap.set(id, 101 + percent);
                    // Emit every 5% for smoother updates
                    if (percent >= lastUploadPercent + 5 || percent === 100) {
                        this.logger.log(`üì§ [${id}] Upload progress: ${percent}%`);
                        this.emitProgress(id);
                        lastUploadPercent = percent;
                    }
                }
            );
            this.logger.log(`‚òÅÔ∏è [${id}] Upload complete!`);

            // Cleanup temp files (downloaded file + any player-script.js debug files)
            fs.unlinkSync(downloadedFile);
            this.cleanupTempFiles(tmpDir, id);

            // Update database
            await this.databaseService.sql`
                UPDATE youtube_downloads 
                SET status = 'completed', object_key = ${objectKey}, filename = ${displayFilename}, file_size = ${fileSize}
                WHERE id = ${id}
            `;

            this.logger.log(`üéâ [${id}] Download complete: ${displayFilename} (${(fileSize / 1024 / 1024).toFixed(2)} MB)`);
            // Emit SSE event for completed status
            this.emitProgress(id);
            // Cleanup progress map
            this.progressMap.delete(id);
        } catch (error) {
            this.logger.error(`‚ùå yt-dlp download failed: ${id}`, error);
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            await this.databaseService.sql`
                UPDATE youtube_downloads SET status = 'failed', error = ${errorMessage} WHERE id = ${id}
            `;
            // Emit SSE event for failed status
            this.emitProgress(id);
            // Cleanup progress map
            this.progressMap.delete(id);
        }
    }

    /**
     * Cleanup temporary files created by yt-dlp
     */
    private cleanupTempFiles(tmpDir: string, id: string) {
        try {
            // Clean up any remaining yt_id.* files in temp dir
            const tempFiles = fs.readdirSync(tmpDir).filter(f => f.startsWith(`yt_${id}`));
            for (const file of tempFiles) {
                try {
                    fs.unlinkSync(path.join(tmpDir, file));
                } catch { /* ignore */ }
            }

            // Clean up player-script.js files in cwd (yt-dlp creates these for debugging)
            const cwd = process.cwd();
            const playerScripts = fs.readdirSync(cwd).filter(f => f.includes('player-script.js'));
            for (const file of playerScripts) {
                try {
                    fs.unlinkSync(path.join(cwd, file));
                    this.logger.debug(`üßπ Cleaned up: ${file}`);
                } catch { /* ignore */ }
            }
        } catch (error) {
            this.logger.debug('Cleanup error (non-critical):', error);
        }
    }

    private async getVideoTitle(id: string): Promise<string | null> {
        const records = await this.databaseService.sql`
            SELECT title FROM youtube_downloads WHERE id = ${id}
        `;
        return records[0]?.title || null;
    }

    /**
     * Get download status
     */
    async getDownloadStatus(id: string): Promise<DownloadResult> {
        const records = await this.databaseService.sql`
            SELECT * FROM youtube_downloads WHERE id = ${id}
        `;

        if (records.length === 0) {
            throw new NotFoundException('Download not found');
        }

        const record = records[0];
        // Get live progress from memory map if processing
        const liveProgress = this.progressMap.get(id);

        return {
            id: record.id,
            videoId: record.video_id,
            title: record.title,
            status: record.status,
            // Get live progress for processing and uploading statuses
            progress: (record.status === 'processing' || record.status === 'uploading')
                ? (liveProgress || 0)
                : (record.status === 'completed' ? 100 : 0),
            fileSize: record.file_size ? parseInt(record.file_size) : undefined,
            filename: record.filename || undefined,
            downloadUrl: record.status === 'completed' ? `/youtube/${id}/file` : undefined,
            error: record.error || undefined,
        };
    }

    /**
     * Find existing completed download for deduplication
     * @param videoId - YouTube video ID
     * @param formatType - 'video' or 'audio'
     * @param quality - Quality string (e.g. '1080p', '720p')
     * @param outputFormat - Output format (e.g. 'mp4', 'mp3')
     * @returns Existing download record if found and not expired
     */
    private async findExistingDownload(
        videoId: string,
        formatType: string,
        quality: string,
        outputFormat: string
    ): Promise<Record<string, unknown> | null> {
        // Find completed downloads with same video_id, format_type, quality
        // and filename ending with the expected extension
        const records = await this.databaseService.sql`
            SELECT * FROM youtube_downloads 
            WHERE video_id = ${videoId}
              AND format_type = ${formatType}
              AND quality = ${quality}
              AND status = 'completed'
              AND object_key IS NOT NULL
              AND expires_at > NOW()
              AND filename LIKE ${'%.' + outputFormat}
            ORDER BY created_at DESC
            LIMIT 1
        `;
        return records.length > 0 ? records[0] : null;
    }

    /**
     * Get presigned download URL for direct R2 download
     */
    async getDownloadUrl(id: string): Promise<string> {
        const records = await this.databaseService.sql`
            SELECT object_key, filename FROM youtube_downloads WHERE id = ${id} AND status = 'completed'
        `;

        if (records.length === 0) {
            throw new NotFoundException('File not found or not ready');
        }

        const record = records[0];
        // Generate presigned URL that expires in 1 hour with filename for download
        return this.r2Service.getPresignedUrl(record.object_key, 3600, record.filename);
    }

    /**
     * Get expired downloads for cleanup
     */
    async getExpiredDownloads() {
        return this.databaseService.sql`
            SELECT id, object_key FROM youtube_downloads WHERE expires_at < NOW()
        `;
    }

    /**
     * Delete a download
     */
    async deleteDownload(id: string, objectKey: string) {
        if (objectKey) {
            await this.r2Service.deleteObject(objectKey);
        }
        await this.databaseService.sql`
            DELETE FROM youtube_downloads WHERE id = ${id}
        `;
    }

    /**
     * Get progress stream for SSE (Server-Sent Events)
     */
    getProgressStream(id: string): Subject<DownloadResult> {
        if (!this.progressSubjects.has(id)) {
            this.progressSubjects.set(id, new Subject<DownloadResult>());
        }
        return this.progressSubjects.get(id)!;
    }

    /**
     * Emit progress update to SSE subscribers
     */
    private async emitProgress(id: string) {
        const subject = this.progressSubjects.get(id);
        if (subject) {
            try {
                const status = await this.getDownloadStatus(id);
                subject.next(status);

                // Complete and cleanup on terminal states
                if (status.status === 'completed' || status.status === 'failed') {
                    subject.complete();
                    this.progressSubjects.delete(id);
                }
            } catch (error) {
                // Ignore errors during emit
            }
        }
    }

    /**
     * Get total storage used by YouTube downloads (in bytes)
     */
    async getTotalStorageUsed(): Promise<number> {
        const result = await this.databaseService.sql`
            SELECT COALESCE(SUM(file_size), 0) as total_size 
            FROM youtube_downloads 
            WHERE status = 'completed' AND object_key IS NOT NULL
        `;
        return parseInt(result[0]?.total_size || '0');
    }

    /**
     * Cleanup old downloads to make space before upload
     * Strategy: Delete expired first, then oldest completed (FIFO)
     * @param requiredSpace - Minimum bytes needed for new upload
     */
    async cleanupStorageIfNeeded(requiredSpace: number): Promise<void> {
        const currentStorage = await this.getTotalStorageUsed();
        const projectedStorage = currentStorage + requiredSpace;
        const threshold = this.STORAGE_QUOTA * this.CLEANUP_THRESHOLD;

        if (projectedStorage <= threshold) {
            this.logger.debug(`üìä Storage OK: ${(currentStorage / 1024 / 1024 / 1024).toFixed(2)}GB / ${(this.STORAGE_QUOTA / 1024 / 1024 / 1024).toFixed(0)}GB`);
            return;
        }

        this.logger.log(`‚ö†Ô∏è Storage near limit: ${(currentStorage / 1024 / 1024 / 1024).toFixed(2)}GB. Cleaning up...`);

        // Calculate how much space we need to free
        const spaceToFree = projectedStorage - threshold + requiredSpace;
        let freedSpace = 0;
        let deletedCount = 0;

        // Step 1: Delete expired downloads first
        const expiredDownloads = await this.databaseService.sql`
            SELECT id, object_key, file_size 
            FROM youtube_downloads 
            WHERE expires_at < NOW() AND object_key IS NOT NULL
            ORDER BY expires_at ASC
        `;

        for (const download of expiredDownloads) {
            if (freedSpace >= spaceToFree) break;
            try {
                await this.deleteDownload(download.id, download.object_key);
                freedSpace += parseInt(download.file_size || '0');
                deletedCount++;
            } catch (error) {
                this.logger.warn(`Failed to delete expired download ${download.id}: ${error}`);
            }
        }

        // Step 2: If still need space, delete oldest completed downloads (FIFO)
        if (freedSpace < spaceToFree) {
            const oldestDownloads = await this.databaseService.sql`
                SELECT id, object_key, file_size, title
                FROM youtube_downloads 
                WHERE status = 'completed' AND object_key IS NOT NULL
                ORDER BY created_at ASC
                LIMIT 20
            `;

            for (const download of oldestDownloads) {
                if (freedSpace >= spaceToFree) break;
                try {
                    await this.deleteDownload(download.id, download.object_key);
                    freedSpace += parseInt(download.file_size || '0');
                    deletedCount++;
                    this.logger.log(`üóëÔ∏è Deleted old download: ${download.title?.substring(0, 30)}...`);
                } catch (error) {
                    this.logger.warn(`Failed to delete download ${download.id}: ${error}`);
                }
            }
        }

        if (deletedCount > 0) {
            this.logger.log(`‚úÖ Storage cleanup: deleted ${deletedCount} downloads, freed ${(freedSpace / 1024 / 1024).toFixed(1)}MB`);
        }
    }

    /**
     * Cleanup progress subject
     */
    cleanupProgressSubject(id: string) {
        const subject = this.progressSubjects.get(id);
        if (subject) {
            subject.complete();
            this.progressSubjects.delete(id);
        }
    }

    /**
     * Try to get direct link info for a format, returns null if unavailable
     * Used internally by getVideoInfo to enrich format options
     */
    private async tryGetDirectLinkInfo(
        url: string,
        formatType: 'video' | 'audio',
        quality: string
    ): Promise<DirectLinkInfo | null> {
        try {
            const result = await this.getDirectLink(url, formatType, quality);
            return {
                url: result.directUrl,
                filename: result.filename,
                expiresIn: result.expiresIn,
            };
        } catch {
            // Silent fail - direct link not available for this format
            return null;
        }
    }

    /**
     * Get direct download link from YouTube for low-quality formats
     * - Video: 720p and below (combined video+audio streams)
     * - Audio: any quality (YouTube provides standalone audio streams)
     * The URL expires after ~6 hours
     */
    async getDirectLink(
        url: string,
        formatType: 'video' | 'audio',
        quality: string
    ): Promise<DirectLinkResult> {
        const videoId = this.extractVideoId(url);
        if (!videoId) {
            throw new BadRequestException('Invalid YouTube URL');
        }

        let formatArg: string;
        let displayQuality: string;

        if (formatType === 'audio') {
            // Audio: use bestaudio or specific bitrate
            // Exclude HLS/DASH manifests with protocol filter
            if (quality === 'bestaudio' || quality === 'best') {
                formatArg = 'bestaudio[protocol^=http]';
                displayQuality = 'Best Audio';
            } else {
                // Try to get specific bitrate (e.g., 128kbps, 192kbps)
                const bitrate = parseInt(quality.replace('kbps', '')) || 128;
                // Prefer m4a (better compatibility) or webm/opus
                // Exclude HLS/DASH manifests
                formatArg = `bestaudio[abr<=${bitrate}][protocol^=http]/bestaudio[protocol^=http]`;
                displayQuality = `${bitrate}kbps`;
            }
        } else {
            // Video: only allow 720p and below (combined streams)
            // Use protocol filter to exclude HLS/DASH (m3u8) manifests
            const height = parseInt(quality.replace('p', '')) || 720;
            if (height > 720) {
                throw new BadRequestException(
                    'Direct link only supports 720p and below for video. Higher qualities require video+audio merging. Use the standard download endpoint instead.'
                );
            }
            // Protocol filter: http or https only (not m3u8_native, etc.)
            formatArg = `best[height<=${height}][protocol^=http]`;
            displayQuality = `${height}p`;
        }

        try {
            const args: string[] = [
                '-f', formatArg,
                '-g',  // Get URL only, don't download
                '-j',  // Also output JSON for metadata
                '--no-warnings',
                '--no-check-certificates',
            ];

            if (this.cookiesPath) {
                args.push('--cookies', this.cookiesPath);
            }

            // Anti-bot measures
            args.push(
                '--user-agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            );

            args.push(url);

            const command = `${this.ytdlpPath} ${args.map(a => /[\s\[\]<>]/.test(a) ? `"${a}"` : a).join(' ')}`;
            this.logger.log(`üîó [${videoId}] Getting direct link for ${formatType} ${quality}...`);
            this.logger.debug(`üìã Command: ${command}`);

            const result = execSync(command, {
                encoding: 'utf-8',
                maxBuffer: 10 * 1024 * 1024,
                timeout: 30000,
            });

            // Parse output: first line is URL, second line is JSON
            const lines = result.trim().split('\n');
            if (lines.length < 2) {
                throw new Error('Failed to extract direct URL');
            }

            const directUrl = lines[0].trim();
            const info = JSON.parse(lines[1]);

            // Validate URL
            if (!directUrl.startsWith('http')) {
                throw new Error('Invalid direct URL returned');
            }

            // Reject HLS/DASH manifest URLs - these are playlists, not direct streams
            if (directUrl.includes('.m3u8') || directUrl.includes('manifest.googlevideo.com')) {
                throw new Error('HLS/DASH manifest returned instead of progressive stream. Use standard download.');
            }

            // Build filename
            const sanitize = (s: string) => s.replace(/[<>:"/\\|?*\x00-\x1f]/g, '').trim();
            const title = info.title || 'media';
            const ext = info.ext || (formatType === 'audio' ? 'm4a' : 'mp4');
            const filename = `${sanitize(title).substring(0, 150)}.${ext}`;

            // Determine quality to display
            let resultQuality = displayQuality;
            if (formatType === 'audio' && info.abr) {
                resultQuality = `${Math.round(info.abr)}kbps`;
            } else if (formatType === 'video' && info.height) {
                resultQuality = `${info.height}p`;
            }

            this.logger.log(`‚úÖ [${videoId}] Direct link ready: ${formatType} ${resultQuality} (expires ~6h)`);

            return {
                videoId: info.id || videoId,
                title: info.title || 'YouTube Video',
                directUrl,
                filename,
                filesize: info.filesize || info.filesize_approx,
                quality: resultQuality,
                expiresIn: '6 hours',
            };
        } catch (error) {
            this.logger.error(`‚ùå [${videoId}] Failed to get direct link:`, error);

            if (error instanceof BadRequestException) {
                throw error;
            }

            throw new BadRequestException(
                'Failed to get direct link. The video may be restricted or unavailable. Try the standard download instead.'
            );
        }
    }
}
