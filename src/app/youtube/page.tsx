'use client';

import { useState, useEffect, useCallback } from 'react';
import Navigation from '@/components/Navigation';
import Toast, { useToast } from '@/components/Toast';
import { PlayIcon, MusicIcon, DownloadIcon, SearchIcon, ClockIcon, CopyIcon, XIcon, ScissorsIcon, WarningIcon, ImageIcon, ListIcon, ChevronUpIcon, ChevronDownIcon, SkipForwardIcon, ArrowUpIcon, ArrowDownIcon, ArrowRightIcon, LightbulbIcon, BookOpenIcon, CheckCircleIcon, XCircleIcon, HourglassWaitIcon, BoltIcon } from '@/components/Icons';
import styles from './page.module.css';

const API_BASE = process.env.NEXT_PUBLIC_CHAT_URL || 'http://localhost:3010';
const STORAGE_KEY = 'youtube_downloads_history';
const EXPIRATION_MS = 60 * 60 * 1000; // 1 hour

interface DownloadHistoryItem {
    id: string;
    title: string;
    thumbnail: string;
    format: string;
    quality: string;
    downloadUrl: string;
    fileSize: number;
    createdAt: number; // timestamp
    expiresAt: number; // timestamp
}

interface FormatOption {
    quality: string;
    value: string;
    filesize?: number;
    directLink?: {
        url: string;
        filename: string;
        expiresIn: string;
    };
}

interface SubtitleInfo {
    lang: string;
    name: string;
    autoGenerated: boolean;
}

interface ChapterInfo {
    title: string;
    startTime: number;
    endTime: number;
}

interface VideoInfo {
    videoId: string;
    title: string;
    thumbnail: string;
    duration: number;
    author: string;
    videoFormats: FormatOption[];
    audioFormats: FormatOption[];
    subtitles: SubtitleInfo[];
    chapters: ChapterInfo[];
}

interface PlaylistVideo {
    videoId: string;
    title: string;
    thumbnail: string;
    duration: number;
    index: number;
}

interface CompletedVideo extends PlaylistVideo {
    status: 'done' | 'failed' | 'skipped';
    format?: string;  // e.g. "1080p MP4"
    fileSize?: number;
}

interface PlaylistInfo {
    playlistId: string;
    title: string;
    author: string;
    videoCount: number;
    videos: PlaylistVideo[];
}

interface DownloadResult {
    id: string;
    videoId: string;
    title: string;
    status: 'pending' | 'queued' | 'processing' | 'uploading' | 'completed' | 'failed';
    progress?: number;
    downloadUrl?: string;
    fileSize?: number;
    filename?: string;
    error?: string;
}

const VIDEO_FORMATS = [
    { value: 'mp4', label: 'MP4 (H.264)', desc: 'Best compatibility' },
    { value: 'webm', label: 'WebM (VP9)', desc: 'Smaller size' },
    { value: 'mkv', label: 'MKV', desc: 'Lossless container' },
];

const AUDIO_FORMATS = [
    { value: 'mp3', label: 'MP3', desc: 'Universal' },
    { value: 'm4a', label: 'M4A (AAC)', desc: 'Apple devices' },
    { value: 'opus', label: 'Opus', desc: 'Best quality/size' },
    { value: 'flac', label: 'FLAC', desc: 'Lossless' },
    { value: 'wav', label: 'WAV', desc: 'Uncompressed' },
];

export default function YouTubePage() {
    const [url, setUrl] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [videoInfo, setVideoInfo] = useState<VideoInfo | null>(null);
    const [formatType, setFormatType] = useState<'video' | 'audio'>('video');
    const [selectedQuality, setSelectedQuality] = useState<string>('');
    const [outputFormat, setOutputFormat] = useState<string>('mp4');
    const [startTime, setStartTime] = useState<string>('');
    const [endTime, setEndTime] = useState<string>('');
    const [clipTitle, setClipTitle] = useState<string>(''); // Chapter/clip title for filename
    const [embedSubtitles, setEmbedSubtitles] = useState(false);
    const [subtitleLang, setSubtitleLang] = useState('en');
    const [sponsorBlock, setSponsorBlock] = useState(false);
    const [isDownloading, setIsDownloading] = useState(false);
    const [downloadResult, setDownloadResult] = useState<DownloadResult | null>(null);
    const [downloadHistory, setDownloadHistory] = useState<DownloadHistoryItem[]>([]);
    // Playlist state
    const [playlistInfo, setPlaylistInfo] = useState<PlaylistInfo | null>(null);
    const [selectedVideos, setSelectedVideos] = useState<Set<string>>(new Set());
    // Download queue for batch playlist download
    const [downloadQueue, setDownloadQueue] = useState<PlaylistVideo[]>([]);
    const [completedFromQueue, setCompletedFromQueue] = useState(0);
    const [completedVideos, setCompletedVideos] = useState<CompletedVideo[]>([]);
    const [showQueueList, setShowQueueList] = useState(false);
    const [activePlaylistInfo, setActivePlaylistInfo] = useState<{ title: string; author: string; playlistId: string; totalVideos: number } | null>(null);
    const [shouldMoveToNext, setShouldMoveToNext] = useState(false); // Trigger to move to next video
    const { toasts, addToast, removeToast } = useToast();

    // LocalStorage helpers
    const getHistory = useCallback((): DownloadHistoryItem[] => {
        if (typeof window === 'undefined') return [];
        try {
            const data = localStorage.getItem(STORAGE_KEY);
            return data ? JSON.parse(data) : [];
        } catch {
            return [];
        }
    }, []);

    const saveToHistory = useCallback((item: DownloadHistoryItem) => {
        const history = getHistory();
        // Remove if exists (update)
        const filtered = history.filter(h => h.id !== item.id);
        const updated = [item, ...filtered].slice(0, 20); // Keep max 20 items
        localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
        setDownloadHistory(updated);
    }, [getHistory]);

    const removeFromHistory = useCallback((id: string) => {
        const history = getHistory();
        const updated = history.filter(h => h.id !== id);
        localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
        setDownloadHistory(updated);
    }, [getHistory]);

    const isExpired = (expiresAt: number): boolean => {
        return Date.now() > expiresAt;
    };

    const formatDuration = (seconds: number) => {
        const mins = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${mins}:${secs.toString().padStart(2, '0')}`;
    };

    const formatSize = (bytes: number | null) => {
        if (!bytes) return 'Unknown';
        if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
        return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    };

    // Parse time string to seconds (supports mm:ss or just seconds)
    const parseTimeToSeconds = (time: string): number => {
        if (!time) return 0;
        if (time.includes(':')) {
            const parts = time.split(':').map(Number);
            if (parts.length === 2) return parts[0] * 60 + parts[1];
            if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
        }
        return parseFloat(time) || 0;
    };

    // Load and cleanup history on mount
    useEffect(() => {
        const history = getHistory();
        // Filter out expired items
        const now = Date.now();
        const validHistory = history.filter(item => item.expiresAt > now);
        if (validHistory.length !== history.length) {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(validHistory));
        }
        setDownloadHistory(validHistory);
    }, [getHistory]);

    // Effect to handle auto-navigation to next video (solves stale closure issue)
    useEffect(() => {
        if (shouldMoveToNext && activePlaylistInfo) {
            setShouldMoveToNext(false);
            // Use timeout to ensure state updates are complete
            const timer = setTimeout(() => {
                if (downloadQueue.length > 0) {
                    const nextVideo = downloadQueue[0];
                    const remaining = downloadQueue.slice(1);
                    setDownloadQueue(remaining);
                    setVideoInfo(null);
                    setDownloadResult(null);
                    setUrl(`https://youtube.com/watch?v=${nextVideo.videoId}`);

                    fetch(`${API_BASE}/youtube/info?url=${encodeURIComponent(`https://youtube.com/watch?v=${nextVideo.videoId}`)}`)
                        .then(res => {
                            if (!res.ok) throw new Error('Failed to fetch');
                            return res.json();
                        })
                        .then(data => {
                            setVideoInfo(data);
                            if (data.videoFormats?.length > 0) {
                                setSelectedQuality(data.videoFormats[0].quality);
                            }
                            addToast(`ðŸ“¥ Loading: ${nextVideo.title}`, 'success');
                        })
                        .catch(() => {
                            // Mark as failed and try next
                            setCompletedVideos(prev => [...prev, {
                                videoId: nextVideo.videoId,
                                title: nextVideo.title,
                                thumbnail: nextVideo.thumbnail,
                                duration: nextVideo.duration,
                                index: prev.length + 1,
                                status: 'failed' as const,
                            }]);
                            setCompletedFromQueue(prev => prev + 1);
                            addToast(`Skipped "${nextVideo.title}" - unavailable`, 'error');
                            // Try next video
                            setShouldMoveToNext(true);
                        });
                } else {
                    // Queue empty - playlist complete
                    addToast(`âœ… Playlist download complete!`, 'success');
                    setVideoInfo(null);
                    setDownloadResult(null);
                }
            }, 500);
            return () => clearTimeout(timer);
        }
    }, [shouldMoveToNext, activePlaylistInfo, downloadQueue, addToast]);

    const handleSearch = async () => {
        if (!url.trim()) {
            addToast('Please enter a YouTube URL', 'error');
            return;
        }

        setIsLoading(true);
        setVideoInfo(null);
        setPlaylistInfo(null);
        setSelectedVideos(new Set());
        setDownloadResult(null);
        // Clear queue on new search
        setDownloadQueue([]);
        setCompletedFromQueue(0);
        setCompletedVideos([]);
        setShowQueueList(false);
        setActivePlaylistInfo(null);

        try {
            // Detect if URL is a playlist (exclude Radio/Mix, Liked, Watch Later)
            const isSpecialList = /list=(RD|LL|WL)/.test(url);
            const isPlaylist = !isSpecialList && (url.includes('list=') || url.includes('/playlist'));

            if (isPlaylist) {
                // Fetch playlist info
                const res = await fetch(`${API_BASE}/youtube/playlist?url=${encodeURIComponent(url)}`);
                if (!res.ok) {
                    const data = await res.json();
                    throw new Error(data.message || 'Failed to fetch playlist info');
                }
                const data = await res.json();
                setPlaylistInfo(data);
                // Select all videos by default
                setSelectedVideos(new Set(data.videos.map((v: PlaylistVideo) => v.videoId)));
                addToast(`Playlist loaded: ${data.videos.length} videos`, 'success');
            } else {
                // Fetch single video info
                const res = await fetch(`${API_BASE}/youtube/info?url=${encodeURIComponent(url)}`);
                if (!res.ok) {
                    const data = await res.json();
                    throw new Error(data.message || 'Failed to fetch video info');
                }
                const data = await res.json();
                setVideoInfo(data);
                // Auto-select first quality
                if (data.videoFormats.length > 0) {
                    setSelectedQuality(data.videoFormats[0].quality);
                }
            }
        } catch (error) {
            addToast(error instanceof Error ? error.message : 'Failed to fetch info', 'error');
        } finally {
            setIsLoading(false);
        }
    };

    const handleDownload = async () => {
        if (!videoInfo || !selectedQuality) return;

        setIsDownloading(true);
        setDownloadResult(null);

        try {
            const res = await fetch(`${API_BASE}/youtube/download`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    url,
                    formatType,
                    quality: selectedQuality,
                    outputFormat,
                    // Only send clip params if user actually changed from default (full video)
                    startTime: startTime && parseTimeToSeconds(startTime) > 0 ? startTime : undefined,
                    endTime: endTime && videoInfo && parseTimeToSeconds(endTime) < videoInfo.duration ? endTime : undefined,
                    clipTitle: clipTitle || undefined, // Chapter title for filename prefix
                    // Subtitle embedding (video only)
                    embedSubtitles: formatType === 'video' && embedSubtitles ? true : undefined,
                    subtitleLang: formatType === 'video' && embedSubtitles ? subtitleLang : undefined,
                    // SponsorBlock sponsor removal
                    sponsorBlock: sponsorBlock ? true : undefined,
                    // Send estimated filesize for auto aria2c (on large files)
                    estimatedFilesize: (() => {
                        const format = currentFormats?.find(f => f.quality === selectedQuality);
                        return format?.filesize;
                    })(),
                }),
            });

            if (!res.ok) {
                const data = await res.json();
                throw new Error(data.message || 'Download failed');
            }

            const data = await res.json();
            setDownloadResult(data);

            // Stream progress via SSE
            streamDownloadProgress(data.id);
        } catch (error) {
            addToast(error instanceof Error ? error.message : 'Download failed', 'error');
            setIsDownloading(false);
        }
    };

    const streamDownloadProgress = (id: string) => {
        const eventSource = new EventSource(`${API_BASE}/youtube/${id}/progress`);

        eventSource.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);

                if (data.error) {
                    eventSource.close();
                    setDownloadResult(data);
                    setIsDownloading(false);
                    addToast(data.error, 'error');
                    return;
                }

                setDownloadResult(data);

                if (data.status === 'completed') {
                    eventSource.close();
                    setIsDownloading(false);
                    addToast('Download ready!', 'success');
                    // Save to history
                    if (videoInfo) {
                        const now = Date.now();
                        saveToHistory({
                            id: data.id,
                            title: videoInfo.title,
                            thumbnail: videoInfo.thumbnail,
                            format: outputFormat,
                            quality: selectedQuality,
                            downloadUrl: data.downloadUrl,
                            fileSize: data.fileSize || 0,
                            createdAt: now,
                            expiresAt: now + EXPIRATION_MS,
                        });
                    }
                } else if (data.status === 'failed') {
                    eventSource.close();
                    setIsDownloading(false);
                    setDownloadResult(data);
                    addToast(data.error || 'Download failed', 'error');
                    if (activePlaylistInfo && videoInfo) {
                        setShouldMoveToNext(true);
                    }
                }
            } catch {
                // Ignore parse errors
            }
        };
    };

    // Function to download next video from queue
    const downloadNextFromQueue = async () => {
        if (downloadQueue.length === 0) {
            // No more videos in queue - playlist complete
            addToast(`âœ… Playlist download complete!`, 'success');
            setVideoInfo(null);
            setDownloadResult(null);
            return;
        }

        const nextVideo = downloadQueue[0];
        const remaining = downloadQueue.slice(1);
        setDownloadQueue(remaining);

        // Load video info for next video
        setUrl(`https://youtube.com/watch?v=${nextVideo.videoId}`);
        setVideoInfo(null);
        setDownloadResult(null);

        try {
            const res = await fetch(`${API_BASE}/youtube/info?url=${encodeURIComponent(`https://youtube.com/watch?v=${nextVideo.videoId}`)}`);
            if (!res.ok) {
                // Track as skipped/failed
                setCompletedVideos(prev => [...prev, {
                    videoId: nextVideo.videoId,
                    title: nextVideo.title,
                    thumbnail: nextVideo.thumbnail,
                    duration: nextVideo.duration,
                    index: prev.length + 1,
                    status: 'skipped',
                }]);
                addToast(`Skipped "${nextVideo.title}" - unavailable`, 'error');
                setCompletedFromQueue(prev => prev + 1);
                // Auto continue to next
                setTimeout(() => downloadNextFromQueue(), 500);
                return;
            }
            const data = await res.json();
            setVideoInfo(data);
            if (data.videoFormats.length > 0) {
                setSelectedQuality(data.videoFormats[0].quality);
            }
            addToast(`ðŸ“¥ Loading: ${nextVideo.title}`, 'success');
        } catch {
            // Track as skipped/failed
            setCompletedVideos(prev => [...prev, {
                videoId: nextVideo.videoId,
                title: nextVideo.title,
                thumbnail: nextVideo.thumbnail,
                duration: nextVideo.duration,
                index: prev.length + 1,
                status: 'failed',
            }]);
            addToast(`Skipped "${nextVideo.title}" - error`, 'error');
            setCompletedFromQueue(prev => prev + 1);
            setTimeout(() => downloadNextFromQueue(), 500);
        }
    };

    const handleFileDownload = () => {
        if (downloadResult?.downloadUrl) {
            // Fast download URLs start with http, standard URLs are relative paths
            const url = downloadResult.downloadUrl.startsWith('http')
                ? downloadResult.downloadUrl
                : `${API_BASE}${downloadResult.downloadUrl}`;
            window.open(url, '_blank');
        }
    };

    const handleHistoryDownload = (item: DownloadHistoryItem) => {
        if (isExpired(item.expiresAt)) {
            addToast('This download has expired and is no longer available', 'error');
            removeFromHistory(item.id);
            return;
        }
        window.open(`${API_BASE}${item.downloadUrl}`, '_blank');
    };

    const copyShareLink = async (item: DownloadHistoryItem) => {
        if (isExpired(item.expiresAt)) {
            addToast('This download has expired and cannot be shared', 'error');
            removeFromHistory(item.id);
            return;
        }
        const shareUrl = `${API_BASE}${item.downloadUrl}`;
        try {
            await navigator.clipboard.writeText(shareUrl);
            addToast('Download link copied to clipboard!', 'success');
        } catch {
            addToast('Failed to copy link', 'error');
        }
    };

    const getTimeRemaining = (expiresAt: number): string => {
        const remaining = expiresAt - Date.now();
        if (remaining <= 0) return 'Expired';
        const minutes = Math.floor(remaining / 60000);
        if (minutes < 60) return `${minutes}m left`;
        return `${Math.floor(minutes / 60)}h ${minutes % 60}m left`;
    };

    // Get currently selected format option
    const getSelectedFormat = (): FormatOption | undefined => {
        const formats = formatType === 'video' ? videoInfo?.videoFormats : videoInfo?.audioFormats;
        return formats?.find(f => f.quality === selectedQuality);
    };

    // Check if format is eligible for direct link (video â‰¤720p or audio)
    const isEligibleForDirectLink = (): boolean => {
        // Not eligible if using clip, subtitles, or sponsorblock
        if (startTime || endTime || sponsorBlock || embedSubtitles) return false;

        if (formatType === 'audio') {
            // Audio direct link only works with native formats
            return ['m4a', 'webm', 'opus'].includes(outputFormat);
        } else {
            // Video direct link only for â‰¤720p AND mp4 format (YouTube serves mp4)
            // MKV/WebM require FFmpeg conversion
            if (outputFormat !== 'mp4') return false;
            const height = parseInt(getSelectedFormat()?.value || '0');
            return height > 0 && height <= 720;
        }
    };

    // Smart download handler - tries direct link first, falls back to yt-dlp
    const handleSmartDownload = async () => {
        if (!videoInfo || !selectedQuality) return;

        // Check if eligible for fast direct link
        if (isEligibleForDirectLink()) {
            setIsDownloading(true);
            setDownloadResult({ id: 'direct', videoId: videoInfo.videoId, title: videoInfo.title, status: 'processing', progress: 0 });
            addToast('âš¡ Getting direct link...', 'success');

            try {
                // Try to get direct link
                const format = getSelectedFormat();
                const quality = formatType === 'audio'
                    ? (format?.value === 'bestaudio' ? 'best' : format?.value || 'best')
                    : (format?.value || '720') + 'p';

                const res = await fetch(`${API_BASE}/youtube/direct-link?url=${encodeURIComponent(url)}&formatType=${formatType}&quality=${quality}`);

                if (res.ok) {
                    const data = await res.json();
                    if (data.directUrl) {
                        // Success! Store direct link for "Get File" button
                        const proxyUrl = `${API_BASE}/youtube/proxy-download?url=${encodeURIComponent(data.directUrl)}&filename=${encodeURIComponent(data.filename)}`;

                        setIsDownloading(false);
                        // Set completed status with direct link URL
                        setDownloadResult({
                            id: 'direct',
                            videoId: videoInfo.videoId,
                            title: videoInfo.title,
                            status: 'completed',
                            progress: 100,
                            downloadUrl: proxyUrl, // Store proxy URL for "Get File" button
                            fileSize: data.filesize || undefined,
                        });

                        addToast('âš¡ Fast download ready!', 'success');
                        return;
                    }
                }
            } catch {
                // Direct link failed, continue to fallback
            }

            // Fallback to standard download
            addToast('Cannot get direct link, fallback to standard download...', 'info');
            setIsDownloading(false);
            setDownloadResult(null);
        }

        // Standard download via yt-dlp
        handleDownload();
    };

    const currentFormats = formatType === 'video' ? videoInfo?.videoFormats : videoInfo?.audioFormats;

    return (
        <div className={styles.container}>
            <div className={styles.backgroundGradient}></div>
            <Navigation />
            <Toast toasts={toasts} removeToast={removeToast} />

            <main className={styles.main}>
                <div className={styles.header}>
                    <h1 className={styles.title}>YouTube Downloader</h1>
                    <p className={styles.subtitle}>Download videos and audio from YouTube</p>
                </div>

                {/* URL Input */}
                <div className={styles.inputSection}>
                    <div className={styles.searchBox}>
                        <input
                            type="text"
                            value={url}
                            onChange={(e) => setUrl(e.target.value)}
                            placeholder="Paste YouTube URL here..."
                            className={styles.urlInput}
                            onKeyDown={(e) => e.key === 'Enter' && handleSearch()}
                            disabled={isLoading}
                        />
                        <button
                            className={styles.searchBtn}
                            onClick={handleSearch}
                            disabled={isLoading || !url.trim()}
                        >
                            {isLoading ? (
                                <div className={styles.spinner}></div>
                            ) : (
                                <>
                                    <SearchIcon size={20} />
                                    Search
                                </>
                            )}
                        </button>
                    </div>
                </div>

                {/* Queue Progress Bar - Always visible when there's a queue or completed videos */}
                {(downloadQueue.length > 0 || completedFromQueue > 0 || completedVideos.length > 0) && (
                    <div className={styles.queueContainer}>
                        {/* Playlist Info Row */}
                        {activePlaylistInfo && (
                            <div className={styles.queuePlaylistRow}>
                                <span className={styles.queueIcon}><ListIcon size={16} /></span>
                                <div className={styles.queuePlaylistInfo}>
                                    <span className={styles.queuePlaylistTitle}>{activePlaylistInfo.title}</span>
                                    <span className={styles.queuePlaylistMeta}>
                                        by {activePlaylistInfo.author} â€¢
                                        <a
                                            href={`https://youtube.com/playlist?list=${activePlaylistInfo.playlistId}`}
                                            target="_blank"
                                            rel="noopener noreferrer"
                                            className={styles.queuePlaylistLink}
                                        >
                                            Open in YouTube â†—
                                        </a>
                                    </span>
                                </div>
                            </div>
                        )}

                        {/* Progress Row */}
                        <div className={styles.queueStatusBar}>
                            <div className={styles.queueProgress}>
                                <span className={styles.queueText}>
                                    Progress: {completedFromQueue + 1} / {activePlaylistInfo?.totalVideos || (completedFromQueue + downloadQueue.length + 1)}
                                </span>
                                <div className={styles.queueProgressTrack}>
                                    <div
                                        className={styles.queueProgressFill}
                                        style={{
                                            width: `${(completedFromQueue / (activePlaylistInfo?.totalVideos || (completedFromQueue + downloadQueue.length + 1))) * 100}%`
                                        }}
                                    />
                                </div>
                            </div>
                            <div className={styles.queueActions}>
                                {(downloadQueue.length > 0 || completedVideos.length > 0) && (
                                    <button
                                        className={styles.queueToggleBtn}
                                        onClick={() => setShowQueueList(!showQueueList)}
                                    >
                                        {showQueueList ? <><ChevronUpIcon size={14} /> Hide</> : <><ChevronDownIcon size={14} /> Show</>} Queue
                                    </button>
                                )}
                                <button
                                    className={styles.queueCancelBtn}
                                    onClick={() => {
                                        setDownloadQueue([]);
                                        setCompletedFromQueue(0);
                                        setCompletedVideos([]);
                                        setShowQueueList(false);
                                        setActivePlaylistInfo(null);
                                        addToast('Queue cancelled', 'success');
                                    }}
                                >
                                    Cancel
                                </button>
                            </div>
                        </div>

                        {/* Expandable Queue List */}
                        {showQueueList && (
                            <div className={styles.queueList}>
                                <div className={styles.queueListItems}>
                                    {/* Completed videos */}
                                    {completedVideos.map((video, idx) => (
                                        <div key={video.videoId} className={`${styles.queueListItem} ${video.status === 'done' ? styles.completed : styles.failed}`}>
                                            <span className={styles.queueStatus}>
                                                {video.status === 'done' ? <CheckCircleIcon size={16} /> : video.status === 'skipped' ? <SkipForwardIcon size={16} /> : <XCircleIcon size={16} />}
                                            </span>
                                            <img src={video.thumbnail} alt="" className={styles.queueListThumb} />
                                            <div className={styles.queueListInfo}>
                                                <span className={styles.queueListIndex}>#{idx + 1}</span>
                                                <span className={styles.queueListTitle}>{video.title}</span>
                                                {video.status === 'done' && video.format && (
                                                    <span className={styles.queueListFormat}>{video.format}</span>
                                                )}
                                            </div>
                                            <span className={styles.queueStatusBadge} data-status={video.status}>
                                                {video.status === 'done' ? 'Done' : video.status === 'skipped' ? 'Skipped' : 'Failed'}
                                            </span>
                                        </div>
                                    ))}

                                    {/* Current video (if videoInfo exists) */}
                                    {videoInfo ? (
                                        <div className={`${styles.queueListItem} ${styles.current}`}>
                                            <span className={styles.queueStatus}>{isDownloading ? <DownloadIcon size={16} /> : <PlayIcon size={16} />}</span>
                                            <img src={videoInfo.thumbnail} alt="" className={styles.queueListThumb} />
                                            <div className={styles.queueListInfo}>
                                                <span className={styles.queueListIndex}>#{completedVideos.length + 1}</span>
                                                <span className={styles.queueListTitle}>{videoInfo.title}</span>
                                            </div>
                                            <span className={styles.queueStatusBadge} data-status={isDownloading ? 'downloading' : 'ready'}>
                                                {isDownloading ? 'Downloading' : downloadResult?.status === 'completed' ? 'Ready' : 'Current'}
                                            </span>
                                        </div>
                                    ) : activePlaylistInfo && downloadQueue.length > 0 ? (
                                        <div className={`${styles.queueListItem} ${styles.current}`}>
                                            <span className={styles.queueStatus}><HourglassWaitIcon size={16} /></span>
                                            <div className={styles.queueListThumbPlaceholder}>
                                                <div className={styles.spinner}></div>
                                            </div>
                                            <div className={styles.queueListInfo}>
                                                <span className={styles.queueListIndex}>#{completedVideos.length + 1}</span>
                                                <span className={styles.queueListTitle}>Loading next video...</span>
                                            </div>
                                            <span className={styles.queueStatusBadge} data-status="downloading">
                                                Loading
                                            </span>
                                        </div>
                                    ) : null}

                                    {/* Pending videos */}
                                    {downloadQueue.map((video, idx) => (
                                        <div key={video.videoId} className={`${styles.queueListItem} ${styles.pending}`}>
                                            <span className={styles.queueStatus}><HourglassWaitIcon size={16} /></span>
                                            <img src={video.thumbnail} alt="" className={styles.queueListThumb} />
                                            <div className={styles.queueListInfo}>
                                                <span className={styles.queueListIndex}>#{completedVideos.length + 2 + idx}</span>
                                                <span className={styles.queueListTitle}>{video.title}</span>
                                            </div>
                                            <div className={styles.queueItemActions}>
                                                {/* Skip to this video button */}
                                                <button
                                                    className={styles.queueSkipBtn}
                                                    onClick={() => {
                                                        // Skip current video and jump to this one
                                                        if (videoInfo && !isDownloading) {
                                                            // Mark current as skipped
                                                            setCompletedVideos(prev => [...prev, {
                                                                videoId: videoInfo.videoId,
                                                                title: videoInfo.title,
                                                                thumbnail: videoInfo.thumbnail,
                                                                duration: videoInfo.duration,
                                                                index: prev.length + 1,
                                                                status: 'skipped' as const,
                                                            }]);
                                                            setCompletedFromQueue(prev => prev + 1);
                                                            // Remove clicked video from queue and put remaining back
                                                            const clickedVideo = downloadQueue[idx];
                                                            const newQueue = downloadQueue.filter((_, i) => i !== idx);
                                                            setDownloadQueue(newQueue);
                                                            // Load clicked video
                                                            setVideoInfo(null);
                                                            setDownloadResult(null);
                                                            setUrl(`https://youtube.com/watch?v=${clickedVideo.videoId}`);
                                                            fetch(`${API_BASE}/youtube/info?url=${encodeURIComponent(`https://youtube.com/watch?v=${clickedVideo.videoId}`)}`)
                                                                .then(res => res.json())
                                                                .then(data => {
                                                                    setVideoInfo(data);
                                                                    if (data.videoFormats?.length > 0) {
                                                                        setSelectedQuality(data.videoFormats[0].quality);
                                                                    }
                                                                    addToast(`ðŸ“¥ Switched to: ${clickedVideo.title}`, 'success');
                                                                })
                                                                .catch(() => {
                                                                    addToast(`Failed to load "${clickedVideo.title}"`, 'error');
                                                                    setTimeout(() => downloadNextFromQueue(), 500);
                                                                });
                                                        }
                                                    }}
                                                    title="Skip to this video"
                                                    disabled={isDownloading}
                                                >
                                                    <SkipForwardIcon size={14} />
                                                </button>
                                                {idx > 0 && (
                                                    <button
                                                        className={styles.queueMoveBtn}
                                                        onClick={() => {
                                                            const newQueue = [...downloadQueue];
                                                            [newQueue[idx - 1], newQueue[idx]] = [newQueue[idx], newQueue[idx - 1]];
                                                            setDownloadQueue(newQueue);
                                                        }}
                                                        title="Move up"
                                                    ><ArrowUpIcon size={14} /></button>
                                                )}
                                                {idx < downloadQueue.length - 1 && (
                                                    <button
                                                        className={styles.queueMoveBtn}
                                                        onClick={() => {
                                                            const newQueue = [...downloadQueue];
                                                            [newQueue[idx], newQueue[idx + 1]] = [newQueue[idx + 1], newQueue[idx]];
                                                            setDownloadQueue(newQueue);
                                                        }}
                                                        title="Move down"
                                                    ><ArrowDownIcon size={14} /></button>
                                                )}
                                            </div>
                                            <span className={styles.queueStatusBadge} data-status="pending">Pending</span>
                                        </div>
                                    ))}                                </div>
                            </div>
                        )}
                    </div>
                )}

                {/* Playlist View */}
                {playlistInfo && (
                    <div className={styles.playlistCard}>
                        <div className={styles.playlistHeader}>
                            <h2><ListIcon size={20} /> {playlistInfo.title}</h2>
                            <span className={styles.playlistMeta}>
                                {playlistInfo.author} â€¢ {playlistInfo.videoCount} videos
                            </span>
                        </div>
                        <div className={styles.playlistActions}>
                            <button
                                className={styles.selectAllBtn}
                                onClick={() => setSelectedVideos(new Set(playlistInfo.videos.map(v => v.videoId)))}
                            >
                                Select All
                            </button>
                            <button
                                className={styles.selectAllBtn}
                                onClick={() => setSelectedVideos(new Set())}
                            >
                                Deselect All
                            </button>
                            <span className={styles.selectedCount}>
                                {selectedVideos.size} / {playlistInfo.videoCount} selected
                            </span>
                        </div>
                        <div className={styles.playlistVideos}>
                            {playlistInfo.videos.map((video) => (
                                <label key={video.videoId} className={`${styles.playlistItem} ${selectedVideos.has(video.videoId) ? styles.selected : ''}`}>
                                    <input
                                        type="checkbox"
                                        checked={selectedVideos.has(video.videoId)}
                                        onChange={(e) => {
                                            const newSet = new Set(selectedVideos);
                                            if (e.target.checked) {
                                                newSet.add(video.videoId);
                                            } else {
                                                newSet.delete(video.videoId);
                                            }
                                            setSelectedVideos(newSet);
                                        }}
                                    />
                                    <img src={video.thumbnail} alt={video.title} className={styles.playlistThumb} />
                                    <div className={styles.playlistItemInfo}>
                                        <span className={styles.playlistIndex}>#{video.index}</span>
                                        <span className={styles.playlistTitle}>{video.title}</span>
                                        <span className={styles.playlistDuration}>{formatDuration(video.duration)}</span>
                                    </div>
                                </label>
                            ))}
                        </div>
                        <div className={styles.playlistDownload}>
                            <p className={styles.playlistNote}>
                                <LightbulbIcon size={16} /> Videos will be downloaded one by one. Unavailable videos will be skipped automatically.
                            </p>
                            <div className={styles.playlistBtnRow}>
                                <button
                                    className={styles.downloadBtn}
                                    disabled={selectedVideos.size === 0}
                                    onClick={() => {
                                        // Set up download queue with all selected videos
                                        const selected = playlistInfo.videos.filter(v => selectedVideos.has(v.videoId));
                                        if (selected.length === 0) return;

                                        // Store remaining videos in queue (skip first)
                                        setDownloadQueue(selected.slice(1));
                                        setCompletedFromQueue(0);

                                        // Save playlist info for queue display
                                        setActivePlaylistInfo({
                                            title: playlistInfo.title,
                                            author: playlistInfo.author,
                                            playlistId: playlistInfo.playlistId,
                                            totalVideos: selected.length,
                                        });

                                        // Start with first video
                                        const firstVideo = selected[0];
                                        setUrl(`https://youtube.com/watch?v=${firstVideo.videoId}`);
                                        setPlaylistInfo(null);
                                        setVideoInfo(null);

                                        // Fetch first video info
                                        fetch(`${API_BASE}/youtube/info?url=${encodeURIComponent(`https://youtube.com/watch?v=${firstVideo.videoId}`)}`)
                                            .then(res => res.json())
                                            .then(data => {
                                                setVideoInfo(data);
                                                if (data.videoFormats?.length > 0) {
                                                    setSelectedQuality(data.videoFormats[0].quality);
                                                }
                                                addToast(`ðŸ“¥ Ready: ${firstVideo.title} (1/${selected.length})`, 'success');
                                            })
                                            .catch(() => {
                                                addToast(`Skipped "${firstVideo.title}" - unavailable`, 'error');
                                                downloadNextFromQueue();
                                            });
                                    }}
                                >
                                    <DownloadIcon size={18} />
                                    Start Download ({selectedVideos.size} videos)
                                </button>
                            </div>
                        </div>
                    </div>
                )}

                {/* Video Info Card */}
                {videoInfo ? (
                    <div className={styles.videoCard}>
                        <div className={styles.videoThumbnail}>
                            <img src={videoInfo.thumbnail} alt={videoInfo.title} />
                            <span className={styles.duration}>
                                <ClockIcon size={14} />
                                {formatDuration(videoInfo.duration)}
                            </span>
                            <button
                                className={styles.thumbnailBtn}
                                onClick={() => window.open(videoInfo.thumbnail.replace('hqdefault', 'maxresdefault'), '_blank')}
                                title="Download Thumbnail"
                            >
                                <ImageIcon size={16} />
                            </button>
                        </div>
                        <div className={styles.videoDetails}>
                            <h2 className={styles.videoTitle}>{videoInfo.title}</h2>
                            <p className={styles.videoAuthor}>{videoInfo.author}</p>

                            {/* Format Type Tabs */}
                            <div className={styles.formatTabs}>
                                <button
                                    className={`${styles.formatTab} ${formatType === 'video' ? styles.active : ''}`}
                                    onClick={() => {
                                        setFormatType('video');
                                        setOutputFormat('mp4');
                                        if (videoInfo.videoFormats.length > 0) {
                                            setSelectedQuality(videoInfo.videoFormats[0].quality);
                                        }
                                    }}
                                >
                                    <PlayIcon size={18} />
                                    Video
                                </button>
                                <button
                                    className={`${styles.formatTab} ${formatType === 'audio' ? styles.active : ''}`}
                                    onClick={() => {
                                        setFormatType('audio');
                                        setOutputFormat('mp3');
                                        if (videoInfo.audioFormats.length > 0) {
                                            setSelectedQuality(videoInfo.audioFormats[0].quality);
                                        }
                                    }}
                                >
                                    <MusicIcon size={18} />
                                    Audio
                                </button>
                            </div>

                            {/* Output Format Selector */}
                            <div className={styles.formatSelector}>
                                <label>Output Format:</label>
                                <select
                                    value={outputFormat}
                                    onChange={(e) => setOutputFormat(e.target.value)}
                                    className={styles.formatSelect}
                                    disabled={isDownloading}
                                >
                                    {(formatType === 'video' ? VIDEO_FORMATS : AUDIO_FORMATS).map((fmt) => (
                                        <option key={fmt.value} value={fmt.value}>
                                            {fmt.label} - {fmt.desc}
                                        </option>
                                    ))}
                                </select>
                            </div>

                            {/* Clip Time Selector with Range Slider */}
                            <div className={styles.clipSelector}>
                                <label><ScissorsIcon size={16} /> Clip (optional):</label>
                                <div className={styles.clipSliderContainer}>
                                    <span className={styles.clipTimeLabel}>{startTime || '0:00'}</span>
                                    <div className={styles.clipRangeWrapper}>
                                        <div className={styles.clipRangeTrack}>
                                            <div
                                                className={styles.clipRangeProgress}
                                                style={{
                                                    left: `${(parseTimeToSeconds(startTime) / videoInfo.duration) * 100}%`,
                                                    width: `${((endTime ? parseTimeToSeconds(endTime) : videoInfo.duration) - parseTimeToSeconds(startTime)) / videoInfo.duration * 100}%`
                                                }}
                                            />
                                        </div>
                                        <input
                                            type="range"
                                            min="0"
                                            max={videoInfo.duration}
                                            step="1"
                                            value={parseTimeToSeconds(startTime)}
                                            onChange={(e) => {
                                                const newStart = parseInt(e.target.value);
                                                const endSec = endTime ? parseTimeToSeconds(endTime) : videoInfo.duration;
                                                if (newStart < endSec) {
                                                    setStartTime(formatDuration(newStart));
                                                }
                                            }}
                                            className={styles.clipRangeInput}
                                            disabled={isDownloading}
                                        />
                                        <input
                                            type="range"
                                            min="0"
                                            max={videoInfo.duration}
                                            step="1"
                                            value={endTime ? parseTimeToSeconds(endTime) : videoInfo.duration}
                                            onChange={(e) => {
                                                const newEnd = parseInt(e.target.value);
                                                const startSec = parseTimeToSeconds(startTime);
                                                if (newEnd > startSec) {
                                                    setEndTime(formatDuration(newEnd));
                                                }
                                            }}
                                            className={styles.clipRangeInput}
                                            disabled={isDownloading}
                                        />
                                    </div>
                                    <span className={styles.clipTimeLabel}>{endTime || formatDuration(videoInfo.duration)}</span>
                                </div>
                                {(startTime || endTime) && (
                                    <span className={styles.clipWarning}><WarningIcon size={14} /> Full video will be downloaded first, then cut</span>
                                )}
                            </div>

                            {/* Chapter List (if available) */}
                            {videoInfo.chapters.length > 0 && (
                                <div className={styles.chapterList}>
                                    <div className={styles.chapterListHeader}><BookOpenIcon size={16} /> Chapters ({videoInfo.chapters.length}):</div>
                                    <div className={styles.chapters}>
                                        {videoInfo.chapters.map((chapter, idx) => (
                                            <label
                                                key={idx}
                                                className={`${styles.chapterItem} ${startTime === formatDuration(chapter.startTime) &&
                                                    endTime === formatDuration(chapter.endTime)
                                                    ? styles.selected
                                                    : ''
                                                    }`}
                                            >
                                                <input
                                                    type="radio"
                                                    name="chapter"
                                                    checked={
                                                        startTime === formatDuration(chapter.startTime) &&
                                                        endTime === formatDuration(chapter.endTime)
                                                    }
                                                    onChange={() => {
                                                        setStartTime(formatDuration(chapter.startTime));
                                                        setEndTime(formatDuration(chapter.endTime));
                                                        setClipTitle(chapter.title); // Save chapter title for filename
                                                    }}
                                                    disabled={isDownloading}
                                                />
                                                <span className={styles.chapterTime}>
                                                    {formatDuration(chapter.startTime)}
                                                </span>
                                                <span className={styles.chapterTitle}>{chapter.title}</span>
                                            </label>
                                        ))}
                                    </div>
                                    {(startTime || endTime) && (
                                        <button
                                            className={styles.clearChapterBtn}
                                            onClick={() => {
                                                setStartTime('');
                                                setEndTime('');
                                                setClipTitle(''); // Clear chapter title
                                            }}
                                            disabled={isDownloading}
                                        >
                                            Clear Selection (Download Full Video)
                                        </button>
                                    )}
                                </div>
                            )}

                            {/* Subtitle Options (Video only) */}
                            {formatType === 'video' && videoInfo.subtitles.length > 0 && (
                                <div className={styles.subtitleSelector}>
                                    <label className={styles.subtitleCheckbox}>
                                        <input
                                            type="checkbox"
                                            checked={embedSubtitles}
                                            onChange={(e) => setEmbedSubtitles(e.target.checked)}
                                            disabled={isDownloading}
                                        />
                                        <span>Embed Subtitles</span>
                                    </label>
                                    {embedSubtitles && (
                                        <select
                                            value={subtitleLang}
                                            onChange={(e) => setSubtitleLang(e.target.value)}
                                            className={styles.subtitleLangSelect}
                                            disabled={isDownloading}
                                        >
                                            {videoInfo.subtitles.map((sub) => (
                                                <option key={sub.lang} value={sub.lang}>
                                                    {sub.name}
                                                </option>
                                            ))}
                                        </select>
                                    )}
                                </div>
                            )}

                            {/* SponsorBlock Option */}
                            <div className={styles.subtitleSelector}>
                                <label className={styles.subtitleCheckbox}>
                                    <input
                                        type="checkbox"
                                        checked={sponsorBlock}
                                        onChange={(e) => setSponsorBlock(e.target.checked)}
                                        disabled={isDownloading}
                                    />
                                    <span>Remove Sponsor Segments (SponsorBlock)</span>
                                </label>
                            </div>

                            {/* Quality Options */}
                            <div className={styles.qualityOptions}>
                                {currentFormats?.map((format) => {
                                    // Check if this format could use direct link (no clips, no sponsorblock, no subtitle embed, compatible format)
                                    const height = parseInt(format.value) || 0;
                                    const canUseDirect = !startTime && !endTime && !sponsorBlock && !embedSubtitles &&
                                        (formatType === 'audio'
                                            ? ['m4a', 'webm', 'opus'].includes(outputFormat)
                                            : (outputFormat === 'mp4' && height > 0 && height <= 720));
                                    return (
                                        <button
                                            key={format.quality}
                                            className={`${styles.qualityBtn} ${selectedQuality === format.quality ? styles.selected : ''} ${canUseDirect ? styles.fastAvailable : ''}`}
                                            onClick={() => setSelectedQuality(format.quality)}
                                            disabled={isDownloading}
                                        >
                                            <span className={styles.qualityLabel}>
                                                {format.quality}
                                                {canUseDirect && <span className={styles.fastBadge}><BoltIcon size={12} /></span>}
                                            </span>
                                        </button>
                                    );
                                })}
                            </div>

                            {/* Download Button */}
                            <button
                                className={`${styles.downloadBtn} ${isEligibleForDirectLink() ? styles.fastDownload : ''}`}
                                onClick={handleSmartDownload}
                                disabled={!selectedQuality || isDownloading}
                            >
                                {isDownloading ? (
                                    <>
                                        <div className={styles.spinner}></div>
                                        {downloadResult?.status === 'uploading'
                                            ? downloadResult?.progress !== undefined && downloadResult.progress > 100
                                                ? `Uploading... ${downloadResult.progress - 101}%`
                                                : 'Uploading to cloud...'
                                            : downloadResult?.progress !== undefined && downloadResult.progress > 0
                                                ? downloadResult.progress >= 100
                                                    ? 'Processing video...'
                                                    : `Downloading... ${downloadResult.progress}%`
                                                : 'Starting...'}
                                    </>
                                ) : isEligibleForDirectLink() ? (
                                    <>
                                        <BoltIcon size={20} />
                                        Fast Download
                                    </>
                                ) : (
                                    <>
                                        <DownloadIcon size={20} />
                                        Download {formatType === 'video' ? 'Video' : 'Audio'}
                                    </>
                                )}
                            </button>

                            {/* Progress Bar */}
                            {isDownloading && downloadResult?.progress !== undefined && downloadResult.progress > 0 && (
                                <div className={styles.progressContainer}>
                                    <div
                                        className={styles.progressBar}
                                        style={{ width: `${downloadResult.progress}%` }}
                                    />
                                </div>
                            )}

                            {/* Download Result */}
                            {downloadResult?.status === 'completed' && (
                                <div className={styles.downloadReady}>
                                    <p>Ready to download!</p>
                                    <button className={styles.getFileBtn} onClick={handleFileDownload}>
                                        <DownloadIcon size={18} />
                                        Get File ({formatSize(downloadResult.fileSize || null)})
                                    </button>

                                    {/* Queue indicator - show next video button */}
                                    {downloadQueue.length > 0 && (
                                        <div className={styles.queueNext}>
                                            <span>{downloadQueue.length} more videos in queue</span>
                                            <button
                                                className={styles.nextVideoBtn}
                                                onClick={() => {
                                                    if (videoInfo) {
                                                        setCompletedVideos(prev => [...prev, {
                                                            videoId: videoInfo.videoId,
                                                            title: videoInfo.title,
                                                            thumbnail: videoInfo.thumbnail,
                                                            duration: videoInfo.duration,
                                                            index: prev.length + 1,
                                                            status: 'done',
                                                        }]);
                                                    }
                                                    setCompletedFromQueue(prev => prev + 1);
                                                    downloadNextFromQueue();
                                                }}
                                            >
                                                Next Video â†’
                                            </button>
                                        </div>
                                    )}
                                </div>
                            )}

                            {downloadResult?.status === 'failed' && (
                                <div className={styles.downloadError}>
                                    <p><XCircleIcon size={16} /> {downloadResult.error || 'Download failed'}</p>
                                    {/* Allow skip to next if queue exists */}
                                    {downloadQueue.length > 0 && (
                                        <button
                                            className={styles.nextVideoBtn}
                                            onClick={() => {
                                                // Track current failed video
                                                if (videoInfo) {
                                                    setCompletedVideos(prev => [...prev, {
                                                        videoId: videoInfo.videoId,
                                                        title: videoInfo.title,
                                                        thumbnail: videoInfo.thumbnail,
                                                        duration: videoInfo.duration,
                                                        index: prev.length + 1,
                                                        status: 'failed',
                                                    }]);
                                                }
                                                setCompletedFromQueue(prev => prev + 1);
                                                downloadNextFromQueue()
                                            }}
                                        >
                                            Skip to Next Video â†’
                                        </button>
                                    )}
                                </div>
                            )}
                        </div>
                    </div>
                ) : activePlaylistInfo && downloadQueue.length > 0 ? (
                    <div className={styles.videoCard}>
                        <div className={styles.videoCardLoading}>
                            <div className={styles.spinner}></div>
                            <h3>Loading next video...</h3>
                            <p>Preparing video #{completedVideos.length + 1} from playlist</p>
                        </div>
                    </div>
                ) : null}

                {/* Download History */}
                {downloadHistory.length > 0 && (
                    <div className={styles.historySection}>
                        <h3 className={styles.historyTitle}><DownloadIcon size={18} /> Recent Downloads</h3>
                        <p className={styles.historySubtitle}>Links expire after 1 hour</p>
                        <div className={styles.historyList}>
                            {downloadHistory.map((item) => (
                                <div key={item.id} className={styles.historyItem}>
                                    <div className={styles.historyThumbnail}>
                                        <img src={item.thumbnail} alt={item.title} />
                                    </div>
                                    <div className={styles.historyInfo}>
                                        <h4 className={styles.historyItemTitle}>{item.title}</h4>
                                        <div className={styles.historyMeta}>
                                            <span>{item.format.toUpperCase()} â€¢ {item.quality}</span>
                                            <span className={styles.historyTimer}>
                                                <ClockIcon size={12} />
                                                {getTimeRemaining(item.expiresAt)}
                                            </span>
                                        </div>
                                    </div>
                                    <div className={styles.historyActions}>
                                        <button
                                            className={styles.historyDownloadBtn}
                                            onClick={() => handleHistoryDownload(item)}
                                            title="Download"
                                        >
                                            <DownloadIcon size={16} />
                                        </button>
                                        <button
                                            className={styles.historyShareBtn}
                                            onClick={() => copyShareLink(item)}
                                            title="Copy Link"
                                        >
                                            <CopyIcon size={16} />
                                        </button>
                                        <button
                                            className={styles.historyDeleteBtn}
                                            onClick={() => removeFromHistory(item.id)}
                                            title="Remove"
                                        >
                                            <XIcon size={16} />
                                        </button>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                )}

                {/* Features */}
                <div className={styles.features}>
                    <div className={styles.feature}>
                        <div className={styles.featureIcon}>
                            <PlayIcon size={24} />
                        </div>
                        <h4>High Quality</h4>
                        <p>Download up to 4K resolution</p>
                    </div>
                    <div className={styles.feature}>
                        <div className={styles.featureIcon}>
                            <ScissorsIcon size={24} />
                        </div>
                        <h4>Skip Sponsors</h4>
                        <p>Auto-remove sponsor segments</p>
                    </div>
                    <div className={styles.feature}>
                        <div className={styles.featureIcon}>
                            <DownloadIcon size={24} />
                        </div>
                        <h4>Super Fast</h4>
                        <p>16x faster with turbo mode</p>
                    </div>
                    <div className={styles.feature}>
                        <div className={styles.featureIcon}>
                            <MusicIcon size={24} />
                        </div>
                        <h4>Playlist</h4>
                        <p>Download entire playlists</p>
                    </div>
                    <div className={styles.feature}>
                        <div className={styles.featureIcon}>
                            <ClockIcon size={24} />
                        </div>
                        <h4>Live Progress</h4>
                        <p>See real-time download status</p>
                    </div>
                </div>

                {/* Disclaimer */}
                <p className={styles.disclaimer}>
                    <WarningIcon size={16} /> This tool is for personal use only. Please respect copyright laws and YouTube&apos;s Terms of Service.
                </p>
            </main>
        </div>
    );
}
